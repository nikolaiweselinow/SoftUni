function ParseModulesAndPoints(s: string; out Err: string): TDictionary<integer, TList<integer>>;
var
  mp, strM, strP, strPs: string;
  keepMP: string;
  i, j: integer;
  m, p: integer;
  dictMP: TDictionary<integer, TList<integer>>;
  points: TList<integer>;
begin
  Err := '';

  dictMP := TDictionary<integer, TList<integer>>.Create;

  // '1{2,45,56};5{12,9,15}'
  keepMP := s;

  while s <> '' do begin
    i := Pos(';', s);
    if i = 0 then begin
      mp := Trim(s);
      s := '';
    end
    else begin
      mp := Copy(s, 1, i-1);
      Delete(s, 1, i); // премахване и на ';'
    end;

    if mp = '' then
      continue;

    i := Pos('{', mp);
    j := Pos('}', mp);
    strM := Trim(Copy(mp, 1, i-1));
    if not TryStrToInt(strM, m) or (i = 0)  or (j = 0) or (i > j) then begin
      Err := Format('Невалиден стрингов формат на "заплатени модули и точки": ''%s''', [keepMP]);
      exit;
    end;

    points := TList<integer>.Create();
    strPs := Trim(Copy(mp, i+1, j-i-1));
    while strPs <> '' do begin
      i := Pos(',', strPs);
      if i = 0 then begin
        strP := Trim(strPs);
        strPs := '';
      end
      else begin
        strP := Trim(Copy(strPs, 1, i-1));
        Delete(strPs, 1, i);
      end;

      if not TryStrToInt(strP, p) then begin
        Err := Format('Невалиден стрингов формат на "заплатени модули и точки"', [keepMP]);
        exit;
      end;

      points.Add(p);
    end;

    dictMP.Add(m, points);
  end;

  Result := dictMP;
end;